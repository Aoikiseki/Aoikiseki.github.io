<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>设计模式</title>
      <link href="/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
      <url>/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><blockquote><p><a href="https://refactoringguru.cn/design-patterns/builder">https://refactoringguru.cn/design-patterns/builder</a></p></blockquote><h2 id="设计模式六大原则"><a href="#设计模式六大原则" class="headerlink" title="设计模式六大原则"></a>设计模式六大原则</h2><blockquote><p><a href="https://www.jianshu.com/p/807bc228dbc2">https://www.jianshu.com/p/807bc228dbc2</a></p></blockquote><ul><li><p>单一职责</p><p>一个类/方法只负责一项职责。<br>比如类A负责职责T，那么A被修改的原因就只有职责T的逻辑发生了改变；如果类A同时负责职责T1和T2，那么当因为T1的逻辑发生改变导致修改A时，会对T2部分也产生修改。</p></li><li><p>里氏替换</p><p>在使用基类的的地方可以任意使用其子类，能保证子类完美替换基类。</p></li><li><p>依赖倒置原则</p><p>高层模块不应该依赖底层模块，二者都该依赖其抽象；抽象不应该依赖细节；细节应该依赖抽象</p><p>高层模块（调用端）调用接口，底层模块（实现端）实现接口，二者直接交互的应该都是接口</p></li><li><p>接口隔离原则</p><p>使用多个相互隔离的小接口，比使用一个大接口要好。</p><p>个人理解有点类似单一职责，对于一个接口应该只负责一个职责，要修改不同的内容，就要提供多个接口</p></li><li><p>迪米特法则</p><p>类间解耦。</p><p>一个类对自己耦合关联的类知道的越少越好，尽量不要和其他类进行直接接触，而是通过中间类进行接触，达到低耦合。</p></li><li><p>开闭原则</p><p>拥抱扩展，拒绝修改</p></li></ul><h2 id="创建型设计模式"><a href="#创建型设计模式" class="headerlink" title="创建型设计模式"></a>创建型设计模式</h2><h3 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h3><p>1.有一个专门的类Factory负责创建其他类并返回<br>2.Factory对象可以通过接收不同的参数创建不同的对象<br>优点：简单<br>缺点：如果需要添加新的类，则if-else条件就会增加，就要修改已有工厂类的逻辑，<strong>违反开闭原则</strong></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> price: <span class="type">Float</span> &#123; <span class="keyword">get</span> <span class="keyword">set</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Milk</span>: <span class="title">Product</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> price: <span class="type">Float</span> <span class="operator">=</span> <span class="number">1.5</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Noodles</span>: <span class="title">Product</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> price: <span class="type">Float</span> <span class="operator">=</span> <span class="number">2.5</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rice</span>: <span class="title">Product</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> price: <span class="type">Float</span> <span class="operator">=</span> <span class="number">0.5</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SimpleFactory</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">createProduct</span>(<span class="params">coins</span>: <span class="type">Int</span>)</span> -&gt; <span class="type">Product</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> coins <span class="operator">&gt;</span> <span class="number">2</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="type">Noodles</span>()</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> type <span class="operator">&gt;</span> <span class="number">1</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="type">Milk</span>()</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="type">Rice</span>()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h3><p>1.将工厂类再进行抽象，每个工厂实例负责特定的产品生产<br>2.如果需要扩展，则增加工厂而不改变工厂类<br>优点：符合开闭原则；将具体产品和生产过程进行抽象，使得用户无需知道具体是何种产品被生产，增加了工厂的替换灵活性<br>缺点：每个产品都需要新增类，代码可能变得臃肿</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">createProduct</span>()</span> -&gt; <span class="type">Product</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MilkFactory</span>: <span class="title">Factory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">createProduct</span>()</span> -&gt; <span class="type">Product</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">Milk</span>()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NoodlesFactory</span>: <span class="title">Factory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">createProduct</span>()</span> -&gt; <span class="type">Product</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">Noodles</span>()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RiceFactory</span>: <span class="title">Factory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">createProduct</span>()</span> -&gt; <span class="type">Product</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">Rice</span>()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h3><p>工厂方法模式中最大的限制在于每个具体工厂只生产一种产品，实际上很多时候一个工厂可以生产多个产品，比如小米的工厂可以生产小米的低端、中端、高端机，华为的工厂可以生产华为的低端、中端、高端机，甚至可以生产除手机之外的其他产品。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">createPhone</span>()</span> -&gt; <span class="type">Phone</span></span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">createTV</span>()</span> -&gt; <span class="type">TV</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Phone</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">TV</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MiFactory</span>: <span class="title">Factory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">createPhone</span>()</span> -&gt; <span class="type">Phone</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">Mi10</span>()</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">createTV</span>()</span> -&gt; <span class="type">TV</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="type">MiTV</span>()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HuaweiFactory</span>: <span class="title">Factory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">createPhone</span>()</span> -&gt; <span class="type">Phone</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">Mate40</span>()</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">createTV</span>()</span> -&gt; <span class="type">TV</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="type">HuaweiTV</span>()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优点：相比于工厂方法模式，支持产品族而非单一产品，在需要多个产品配合使用的场景中，可以通过切换工厂达到目的<br>缺点：开闭原则有倾斜，新增产品族和工厂很简单，新增产品则很困难，需要修改接口<br>应用场景：控件主题，控件的各种样式属性可以作为配置项，每一个主题都包含多种需要配置的属性。这里配置项Configuration就是Factory，需要配置的属性就是产品族</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">TextStyleConfiguration</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">getFont</span>()</span> -&gt; <span class="type">UIFont</span></span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">getForegroundColor</span> </span>-&gt; <span class="type">UIColor</span></span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">getBackgroundColor</span> </span>-&gt; <span class="type">UIColor</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TitleStyleConfiguration</span>: <span class="title">TextStyleConfiguration</span> </span>&#123;</span><br><span class="line">  <span class="operator">...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ContentStyleConfiguration</span>: <span class="title">TextStyleConfiguration</span> </span>&#123;</span><br><span class="line">  <span class="operator">...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="工厂模式总结"><a href="#工厂模式总结" class="headerlink" title="工厂模式总结"></a>工厂模式总结</h4><p>可以对VC使用工厂方法模式/简单工厂模式，将通用的逻辑放到父VC，根据条件返回对应的子VC。而对于各种成套的配置项则可以考虑使用抽象工厂模式。</p><h3 id="生成器模式"><a href="#生成器模式" class="headerlink" title="生成器模式"></a>生成器模式</h3><p>在建造房屋时，不同房屋的结构是不一样的，比如窗户的数量，卫浴的数量，阁楼的有无等等，应对这种需求有两种方法：</p><ul><li>超级构造函数</li><li>不断从House基类中派生子类</li></ul><p>生成器模式提供了第三种思路，将对象的构建步骤抽取出来，使得构造过程中的每一步都独立出来。将对象的构造过程交给Builder，而每一步骤如何创建对应部件可以自定义。</p><p>一个标准的生成器模式包括如下几个部分：</p><ul><li>protocol Builder：用于定义生产产品的通用步骤，将步骤抽取出来，如何使用由Director决定</li><li>class ConcreteBuilder：提供不同产品对于通用步骤的不同实现，也可以不遵循通用步骤</li><li>class Product：特定步骤下产生的具体产品</li><li>class Director：定义调用构造步骤的顺序</li><li>class Client：客户端将Director和Builder进行关联并得到产品</li></ul><p><img src="https://refactoringguru.cn/images/patterns/diagrams/builder/structure-indexed.png" alt="生成器设计模式结构"></p><h4 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h4><ul><li><p>通过Builder协议将构造过程抽取为单个方法</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Protocol</span> <span class="type">Builder</span> &#123;</span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">reset</span>()</span></span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">buildStep1</span>()</span></span><br><span class="line">   <span class="function"><span class="keyword">func</span> <span class="title">buildStep2</span>()</span></span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">buildStep3</span>()</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>具体生成器实现Builder协议中的构造方法，并提供获取最终产品的方法</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteBuilder</span>: <span class="title">Builder</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">reset</span>()</span> &#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">buildStep1</span>()</span> &#123;&#125;</span><br><span class="line">   <span class="function"><span class="keyword">func</span> <span class="title">buildStep2</span>()</span> &#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">buildStep3</span>()</span> &#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">getResult</span>()</span> -&gt; <span class="type">Product</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>如果把Builder比做真正构造产品的工人，那么Director就是Client请来的监工，负责根据当前环境指导和监督Builder生产产品。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Director</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> builder: <span class="type">Builder</span></span><br><span class="line">  <span class="function"><span class="keyword">init</span>(<span class="params">builder</span>: <span class="type">Builder</span>)</span> &#123; <span class="keyword">self</span>.builder <span class="operator">=</span> builder &#125;</span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">changeBuilder</span>(<span class="params">builder</span>: <span class="type">Builder</span>)</span></span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">makeProduct</span>()</span> &#123;</span><br><span class="line">        <span class="comment">// 指导和监督builder根据环境生产产品</span></span><br><span class="line">      builder.reset()</span><br><span class="line">      <span class="keyword">if</span> environment <span class="operator">==</span> .type1 &#123;</span><br><span class="line">          builder.buildStep1()</span><br><span class="line">            builder.buildStep2()</span><br><span class="line">            builder.buildStep3()</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          builder.buildStep1()</span><br><span class="line">            builder.buildStep3()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Client</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> builder <span class="operator">=</span> <span class="type">ConcreteBuilder</span>()</span><br><span class="line"><span class="keyword">let</span> director <span class="operator">=</span> <span class="type">Director</span>(builder)</span><br><span class="line">director.makeProduct()</span><br><span class="line"><span class="keyword">let</span> product <span class="operator">=</span> builder.getResult()</span><br></pre></td></tr></table></figure></li></ul><h4 id="更加常见的生成器模式以及链式调用"><a href="#更加常见的生成器模式以及链式调用" class="headerlink" title="更加常见的生成器模式以及链式调用"></a>更加常见的生成器模式以及链式调用</h4><p>标准的生成器模式是一个比较复杂的实现方式，在工程中较为常用的就是用builder替代类中每个属性的setter，将setter抽取为buildStep，同时每个buildStep可以返回当前builder，即可达到链式调用的效果，下面是Swift实现的小例子：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">House</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> wall: <span class="type">Int</span></span><br><span class="line">    <span class="keyword">var</span> window: <span class="type">Int</span></span><br><span class="line">    <span class="keyword">var</span> table: <span class="type">Int</span></span><br><span class="line">    <span class="keyword">var</span> chair: <span class="type">Int</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">init</span>(<span class="params">builder</span>: <span class="type">Builder</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.wall <span class="operator">=</span> builder.wall</span><br><span class="line">        <span class="keyword">self</span>.window <span class="operator">=</span> builder.window</span><br><span class="line">        <span class="keyword">self</span>.table <span class="operator">=</span> builder.table</span><br><span class="line">        <span class="keyword">self</span>.chair <span class="operator">=</span> builder.chair</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Builder</span> </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> wall: <span class="type">Int</span> <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">var</span> window: <span class="type">Int</span> <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">var</span> table: <span class="type">Int</span> <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">var</span> chair: <span class="type">Int</span> <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">func</span> <span class="title">setWall</span>(<span class="params">wall</span>: <span class="type">Int</span>)</span> -&gt; <span class="type">Builder</span> &#123;</span><br><span class="line">            <span class="keyword">self</span>.wall <span class="operator">=</span> wall</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">self</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">func</span> <span class="title">setWindow</span>(<span class="params">window</span>: <span class="type">Int</span>)</span> -&gt; <span class="type">Builder</span> &#123;</span><br><span class="line">            <span class="keyword">self</span>.window <span class="operator">=</span> window</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">self</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">func</span> <span class="title">setTable</span>(<span class="params">table</span>: <span class="type">Int</span>)</span> -&gt; <span class="type">Builder</span> &#123;</span><br><span class="line">            <span class="keyword">self</span>.table <span class="operator">=</span> table</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">self</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">func</span> <span class="title">setChair</span>(<span class="params">chair</span>: <span class="type">Int</span>)</span> -&gt; <span class="type">Builder</span> &#123;</span><br><span class="line">            <span class="keyword">self</span>.chair <span class="operator">=</span> chair</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">self</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">func</span> <span class="title">getHouse</span>()</span> -&gt; <span class="type">House</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="type">House</span>(builder: <span class="keyword">self</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用处</span></span><br><span class="line"><span class="keyword">let</span> hosue <span class="operator">=</span> <span class="type">House</span>.<span class="type">Builder</span>().setWall(wall: <span class="number">1</span>).setTable(table: <span class="number">2</span>).setChair(chair: <span class="number">3</span>).setWindow(window: <span class="number">4</span>).getHouse()</span><br></pre></td></tr></table></figure><h4 id="生成器模式总结"><a href="#生成器模式总结" class="headerlink" title="生成器模式总结"></a>生成器模式总结</h4><p>优点</p><ul><li>将构造代码从业务逻辑中抽取出来</li><li>生产不同产品时可以复用来自Director的相同的构造代码，只需要提供不同的Builder实现即可</li><li>适用于构造步骤相对固定的场景</li></ul><p>缺点</p><ul><li>代码很可能更加臃肿</li></ul><p>使用场景</p><ul><li><p>创建对象的算法（Builder）独立于其组成部分和装配方式（Director），使得利用Director我们可以用同样的步骤传入不同的Builder来创建不同的对象。</p><blockquote><p>实例来源<a href="https://www.iteye.com/topic/1125714">https://www.iteye.com/topic/1125714</a></p><p>为了导出数据，需要进行特定的步骤：1.拼接文件头 2.拼接文件体 3.拼接文件尾 4.输出文件，而不同的输出格式txt、xml等对这几步的处理方式不同，但步骤是一样的，此时就可以用生成器模式。根据输出不同文件的算法创建不同的Builder，Director负责调用Builder完成整个导出工作。</p></blockquote></li><li><p>如果类中包含大量属性（比如几十个），每个属性的设置和不设置形成了大量的排列组合结果，而如果将这些属性的设置都放到init中，init的函数体会变得相当大，而且init中可能会包含其他业务逻辑，此时通过将这些属性抽取为buildStep，就将属性的设置和业务逻辑分离开，并且可读性更强。（貌似对于Swift来说，这部分的优势少了很多）</p></li></ul><h2 id="结构型设计模式"><a href="#结构型设计模式" class="headerlink" title="结构型设计模式"></a>结构型设计模式</h2><blockquote><p>结构型模式描述如何将类或者对象结合在一起形成更大的结构</p></blockquote><h3 id="适配器模式（Adapter、Wrapper）"><a href="#适配器模式（Adapter、Wrapper）" class="headerlink" title="适配器模式（Adapter、Wrapper）"></a>适配器模式（Adapter、Wrapper）</h3><h4 id="对象适配器"><a href="#对象适配器" class="headerlink" title="对象适配器"></a>对象适配器</h4><p>服务器可以处理Json格式的数据，但是从客户端收集的数据只有XML，这时就需要对数据格式进行转换，适配器就是完成这样一种工作。在本例中假定服务器的代码我们难以修改，那么新建的适配器就是为了适配服务器代码，服务端被称为adaptee，是难以修改的部分。适配器要完成数据转换的同时，要让用户有一种和服务端直接交互的感觉。</p><p>对象适配器的实现可以分为如下几步骤：</p><ul><li>声明面向客户的接口Adapter，约定服务端和客户端理想的交互方式</li><li>实现具体的ConcreteAdapter，持有adaptee</li><li>实现ConcreteAdapter中的交互方法</li></ul><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Service</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">analysisData</span>(<span class="params">data</span>: <span class="type">JSON</span>)</span> -&gt; <span class="type">Data</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Adapter</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">getResult</span>(<span class="params">data</span>: <span class="type">XML</span>)</span> -&gt; <span class="type">Data</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteAdapter</span>: <span class="title">Adapter</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> adaptee: <span class="type">Service</span></span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">getResult</span>(<span class="params">data</span>: <span class="type">XML</span>)</span> -&gt; <span class="type">Data</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> jsonData <span class="operator">=</span> convertFormat(data)</span><br><span class="line">      <span class="keyword">return</span> adaptee.analysisData(jsonData)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="类适配器"><a href="#类适配器" class="headerlink" title="类适配器"></a>类适配器</h4><p>借助多重继承机制，将ConcreteAdapter实现为Adaptee的子类，从而无需持有adaptee就可以使用Service的方法</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Service</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">analysisData</span>(<span class="params">data</span>: <span class="type">JSON</span>)</span> -&gt; <span class="type">Data</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Adapter</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">getResult</span>(<span class="params">data</span>: <span class="type">XML</span>)</span> -&gt; <span class="type">Data</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteAdapter</span>: <span class="title">Adapter</span>, <span class="title">Service</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">getResult</span>(<span class="params">data</span>: <span class="type">XML</span>)</span> -&gt; <span class="type">Data</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> jsonData <span class="operator">=</span> convertFormat(data)</span><br><span class="line">      <span class="keyword">return</span> analysisData(jsonData)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="对象适配器-VS-类适配器"><a href="#对象适配器-VS-类适配器" class="headerlink" title="对象适配器 VS 类适配器"></a>对象适配器 VS 类适配器</h4><p>对象适配器：可以持有多个Adaptee，从而调用不同的服务接口，但是不能修改Adaptee的实现<br>类适配器：无需持有Adaptee，可以修改继承来的实现</p><h2 id="外观设计模式Facade"><a href="#外观设计模式Facade" class="headerlink" title="外观设计模式Facade"></a>外观设计模式Facade</h2><p>当你的客户类需要与许多提供功能的类进行交互，却只用到每个类中很少的几个方法，甚至功能类之间还有横向的交互，如果将所有功能类直接交给客户类去使用，客户类中要控制的逻辑会非常的复杂。</p><p>此时可以通过加一个“中间层”对逻辑进行整理：</p><ul><li>将功能类横向交互交给中间层去管理</li><li>只给客户类暴露其真正需要的方法</li></ul><p>这个“中间层”就是外观类Facade，外观模式差不多也是项目中最常用的模式了，对于复杂的逻辑简单地加一个中间层就可以让代码对客户类变得简单清晰。</p><p><img src="https://refactoringguru.cn/images/patterns/diagrams/facade/structure-indexed.png" alt="外观设计模式的结构"></p><h4 id="外观模式总结"><a href="#外观模式总结" class="headerlink" title="外观模式总结"></a>外观模式总结</h4><p>优点</p><ul><li>代码独立于复杂的子系统</li><li>简单</li></ul><p>缺点</p><ul><li>外观类可能会与所有类都耦合</li></ul><p>应用场景</p><ul><li>需要指向一套复杂子系统的简单接口，可以使用外观模式创建中间类</li><li>需要将子系统组织为多层结构，可以利用外观模式定义每一层的入口</li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTP</title>
      <link href="/HTTP/"/>
      <url>/HTTP/</url>
      
        <content type="html"><![CDATA[<h1 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h1><blockquote><p>HTTP是基于TCP协议实现的超文本传输协议</p></blockquote><h2 id="HTTP的特点"><a href="#HTTP的特点" class="headerlink" title="HTTP的特点"></a>HTTP的特点</h2><ul><li>C/S模式：客户端主动发出请求，服务端给予回应</li><li>简单快速：只需要传输路径和请求方法</li><li>灵活：通过Content-Type标识，允许传输任意数据类型</li><li><strong>无连接</strong>：与UDP的无连接不同，这里的无连接的意思是每个HTTP连接只处理一个请求。<br>随着网页越来越复杂，这种处理方式效率低下，开始使用<code>Connetcion: keep-alive</code>字段保持<strong>TCP</strong>连接不断开</li><li><strong>无状态</strong>：对事务的处理没有记忆能力，服务端不会记录客户端状态，这次请求依赖上次的请求仍然需要重传。<br>目前有cookie和session两种方式提高传输效率</li></ul><h2 id="URI、URL、URN"><a href="#URI、URL、URN" class="headerlink" title="URI、URL、URN"></a>URI、URL、URN</h2><ul><li>URI：统一资源标识符。可以对网络中的资源进行标识，使得资源之间能够被区分。</li><li>URL：统一资源定位符。对某一资源提供了具体的访问地址和访问方式。</li></ul><p>显然URI &gt;= URL，能够提供具体访问方式的资源都是URI，但是并不是所有URI都提供了访问方式 。HTTP请求中请求的是URI，但是由于绝大部分情况都是根据资源地址进行请求，所以大部分时候也是URL。</p><h2 id="HTTP的报文结构"><a href="#HTTP的报文结构" class="headerlink" title="HTTP的报文结构"></a>HTTP的报文结构</h2><h3 id="请求报文"><a href="#请求报文" class="headerlink" title="请求报文"></a>请求报文</h3><p>![image-20201115184052614](/Users/yuanhao/Library/Application Support/typora-user-images/image-20201115184052614.png)</p><p>上面图示的报文头包含了比较常用的报文头字段，只是所有报文头字段的一部分，报文头字段总体可以分为通用报文头、请求报文头、响应报文头和实体报文头四类，在HTTP/1.1中一共规范了47种报文头字段。</p><p>下面对比较常用的字段进行说明</p><ul><li>ACCEPT：浏览器端可以接受的媒体类型。比如text/html就是可以接受服务端返回的text/html类型，如果服务端没有对应类型，则返回406错误；而*/*代表浏览器可以接受所有类型。</li><li>Connection：<code>keep-alive</code>代表TCP连接不关闭，<code>close</code>代表TCP连接在一次请求后就会关闭。</li><li>Refer：告诉服务端，是从哪个页面链接过来的。</li><li>User-Agent：客户端的操作系统和浏览器版本</li><li>Content-Type：报文体内对象的媒体类型。在项目中比较常用的就是<code>application/json</code>。</li></ul><h3 id="响应报文"><a href="#响应报文" class="headerlink" title="响应报文"></a>响应报文</h3><p>![image-20201115191453071](/Users/yuanhao/Library/Application Support/typora-user-images/image-20201115191453071.png)</p><h2 id="HTTP的请求方法"><a href="#HTTP的请求方法" class="headerlink" title="HTTP的请求方法"></a>HTTP的请求方法</h2><ul><li><p>GET：用来请求和访问已被URI识别的资源。GET也可以用来发送表单，提交数据，但提交信息直接拼在URI后面，一个是安全隐患，一个是有长度限制（不同的浏览器限制不同）</p></li><li><p>POST：与GET功能类似，但是用来传输实体的主体。由于表单数据没有直接拼在URI后面，也没有大小限制，所以克服了GET请求的缺点。</p><p>但是不论是GET还是POST请求，都不安全，比如抓包软件都拦截，只是POST相比GET提交数据，安全了一丢丢。</p></li><li><p>PUT：从客户端向服务端传送的数据取代指定文档的内容，与POST的区别在于，PUT是幂等的而POST是非幂等的，比如创建对象用POST，更新对象用PUT。</p></li><li><p>HEAD：类似GET请求，只是响应中没有具体内容。用于探测某个链接是否有效。</p></li><li><p>DELETE：由于没有验证机制，几乎没人用。</p></li><li><p>OPTIONS</p></li><li><p>TRACE</p></li><li><p>CONNECT：开启客户端与所请求资源之间的双向通道，可以用来创建隧道。目前只在代理中用的比较多。</p></li></ul><h2 id="HTTP状态码"><a href="#HTTP状态码" class="headerlink" title="HTTP状态码"></a>HTTP状态码</h2><p>2XX成功</p><ul><li>200：已接受并成功返回。</li><li>202：已接受但尚未处理完。</li><li>206：服务器成功处理了部分GET请求。断点续传、流媒体传输常用。</li></ul><p>3XX重定向</p><ul><li>301：请求的资源被永久移动到新的URI</li><li>302：临时移动</li></ul><p>4XX服务端结果可能不尽人意</p><ul><li>400：客户端请求语法错误</li><li>401：身份认证</li><li>403：服务端理解客户端请求，但拒绝执行</li><li>404：找不到资源</li></ul><p>5XX服务器错误</p><ul><li>500：服务器内部错误</li><li>502：网关或代理与远端服务器传输数据时发生了错误</li></ul><h2 id="HTTP状态管理"><a href="#HTTP状态管理" class="headerlink" title="HTTP状态管理"></a>HTTP状态管理</h2><p>HTTP通过Cookie和Session的方式来进行状态管理，其中Cookie是客户端的状态，Session是服务端的状态。</p><h3 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h3><p>Cookie实际上是一小段文本信息，客户端请求服务器如果需要存储客户端的信息，则服务端会向客户端发送一段Cookie。客户端浏览器会将Cookie存储起来，当浏览器再请求该网站时，就会带上Cookie，服务器就可以凭借Cookie辨认用户。</p><h3 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h3><p>Session是服务端存储用户状态的方式，服务端收到客户端发送的请求后，若用户此前未请求过，则为用户创建一个Session并生成SessionID，并将SessionID返回给客户端，以后客户端发送请求时携带SessionID即可。</p><p>保存SessionID的方式：</p><ul><li>Cookie</li><li>URL重写</li><li>隐藏表单</li></ul><p>由于Session一般都放到服务端的缓存中，所以为了减缓存储压力，所以会对不活跃的Session进行释放，所以Session的有效期相对较短，而Cookie可以永久存储。</p><h2 id="字符集与编码"><a href="#字符集与编码" class="headerlink" title="字符集与编码"></a>字符集与编码</h2><h3 id="编码规范"><a href="#编码规范" class="headerlink" title="编码规范"></a>编码规范</h3><p>编码规范（比如Unicode）包括三部分：</p><ul><li>字库表</li><li>编码方式（比如UTF-8）</li><li>字符集</li></ul><p>常见的编码规范：</p><ul><li>ASCII：最为人熟知的编码方式，字符只占一个字节，但是可表达的字符非常少</li><li>GBK：所有字符都占两个字节</li><li>ISO-8859-1：也是只占一个字节，但是表示的是ASCII以外的字符。最大的特点就是其他任何的编码规范都可以尝试用ISO-8859-1进行解码，虽然结果很可能不是你想要的，很多时候乱码就是这样产生的，一些数据库也利用了这个特点。该规范不支持中文。</li><li>Unicode：ISO标准化组织定制的一种通用编码规范，该规范下包括utf-8（变长）、utf-16、utf-32编码方式</li></ul><p>编码：文字-&gt;机器码</p><p>解码：机器码-&gt;文字</p><h3 id="乱码是如何产生的？"><a href="#乱码是如何产生的？" class="headerlink" title="乱码是如何产生的？"></a>乱码是如何产生的？</h3><p>有两种可能</p><ol><li>编码和解码使用的规范不一致</li><li>编码和解码规范一致，但是字库表并没有这些字，比如使用iSO-8859-1对中文字符进行编码和解码，无法还原文本。</li></ol><h3 id="URL的编码和解码"><a href="#URL的编码和解码" class="headerlink" title="URL的编码和解码"></a>URL的编码和解码</h3><ul><li>URL使用ASCII字符集进行编码，因此如果URL含有非ASCII字符集的字符，则需要进行编码</li><li>URL中的一些保留字符，比如参数分隔符”&amp;”，如果想要使用保留字，也需要编码</li></ul><p>URL中的”%”编码规范</p><ul><li>对于URL中的ASCII字符集的非保留字不编码</li><li>对于保留字取其ASCII内码，然后加上%前缀进行编码</li><li>对于非ASCII字符取其Unicode内码，加上%前缀进行编码</li></ul><h2 id="身份认证"><a href="#身份认证" class="headerlink" title="身份认证"></a>身份认证</h2><ul><li>Basic认证：简单的Base64加密传输。</li><li>Digest摘要认证：HTTP/1.1起出现，服务端传送一个加密算法，客户端使用该加密算法进行加密传输。</li><li>SSL认证：借由HTTPS的客户端证书完成认证，具备一定的成本。</li><li>基于表单的认证：该认证方法并不是在HTTP协议中定义的，而是有Web应用程序进行实现，通过Cookie和Session保存用户状态。</li></ul><h2 id="长连接和短连接"><a href="#长连接和短连接" class="headerlink" title="长连接和短连接"></a>长连接和短连接</h2><p>长连接和短连接的概念其实是来描述TCP，而非HTTP的。</p><ul><li>短连接：建立连接、数据传输、关闭连接…建立连接、数据传输、关闭连接</li><li>长连接：建立连接、数据传输…数据传输、关闭连接</li></ul><h2 id="HTTP缓存"><a href="#HTTP缓存" class="headerlink" title="HTTP缓存"></a>HTTP缓存</h2><p>HTTP的缓存对象更多是静态资源文件、比如css、js、图片等资源。</p><h3 id="缓存头部字段："><a href="#缓存头部字段：" class="headerlink" title="缓存头部字段："></a>缓存头部字段：</h3><ul><li><p>Cache-Control请求/响应头，缓存控制字段</p><p>no-store：不缓存</p><p>no-cache：缓存，但是使用缓存前需要询问服务器资源是否最新</p><p>public：客户端和代理服务器都可以缓存</p><p>private：客户端可以缓存</p><p>max-age=x：请求缓存后的X秒内不再发起请求</p><p>s-maxage=x：作用同上，用于代理服务器和源站</p></li><li><p>Expires响应头，过期时间</p></li><li><p>Last-Modified响应头，资源最新修改时o间</p><p>if-Modified-Since请求头，资源最新修改时间</p></li><li><p>Etag响应头，资源标识</p><p>if-None-Match请求头，缓存资源标识</p></li></ul><h3 id="缓存的三种工作场景："><a href="#缓存的三种工作场景：" class="headerlink" title="缓存的三种工作场景："></a>缓存的三种工作场景：</h3><ul><li><p>客户端向服务端请求资源，服务端返回资源+Expires，客户端再次请求前先去查看Expires</p></li><li><p>客户端向服务端请求资源，服务端返回资源+Expires+Last-Modified，客户端再次请求会带上if-Modified-Since，若服务端比对发现资源仍然未改动，则直接返回304</p><p>两个问题：</p><ol><li>Expires在客户端可以被修改，因此不稳定</li><li>Last-Modified只能精确到秒级，造成无法及时更新（可以抓包看一下）</li></ol></li><li><p>客户端向服务端请求资源，服务端返回资源+Expires+Last-Modified+Etag+max-age，用max-age解决问题1，用Etag解决问题2，一旦比对Etag不匹配，则立即更新缓存</p></li></ul><h3 id="缓存改进方案"><a href="#缓存改进方案" class="headerlink" title="缓存改进方案"></a>缓存改进方案</h3><ul><li>md5/hash缓存</li><li>CDN（目前最常用）</li></ul><h2 id="断点续传"><a href="#断点续传" class="headerlink" title="断点续传"></a>断点续传</h2><p>下载使用的也是HTTP协议，可以在Range字段中指定要下载的范围</p><p>HTTP/1.1 200 OK 不使用断点续传</p><p>HTTP/1.1 206 Partial Content 使用断点续传</p><h1 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h1><p>http协议不对内容进行加密，容易被截获和修改</p><h2 id="非对称加密"><a href="#非对称加密" class="headerlink" title="非对称加密"></a>非对称加密</h2><p>A与B进行通信，分三步</p><ul><li>A向B发送Public Key</li><li>B收到Public Key后将准备进行通信的Core Key使用Public Key进行加密得到Secret Key，发送给A</li><li>A收到Secret Key后使用Private Key解密得到Core Key</li></ul><p>这样，即使Public Key在最开始被截获，但是真正用于加密通信的Core Key在网络上没有明文传输，所以是<strong>相对</strong>安全的。非对称加密并不是绝对安全的，因为中间人可能会在第一步截获Public Key，并偷梁换柱向B发送自己制造的Public Key2，从而影响后续的信息传输。</p><h2 id="证书机制"><a href="#证书机制" class="headerlink" title="证书机制"></a>证书机制</h2><p>考虑到非对称加密并非绝对安全，这里引入了证书机构，一般来说我们的浏览器中都设置好了各大证书机构的信息，所以浏览器可以直接进行解密。</p><p>还是A与B进行通信</p><ul><li>A通过向证书机构发送Public Key得到下发的证书，并向B发送证书而非Public Key</li><li>B使用证书机构的公钥对证书进行解密得到Public Key，并将Core Key加密为Secret Key，发送给A</li><li>A收到Secret Key后使用Private Key解密得到Core Key</li></ul><p>整个流程后50%没有变化，只是前50%的流程引入了证书机构</p><h1 id="WebSocket"><a href="#WebSocket" class="headerlink" title="WebSocket"></a>WebSocket</h1><p>WebSocket是HTTP的长连接实现，并且兼容了现有的HTTP协议</p><h2 id="WebSocket的握手"><a href="#WebSocket的握手" class="headerlink" title="WebSocket的握手"></a>WebSocket的握手</h2><p>WebSocket借用HTTP完成握手</p><p>客户端向服务端发送的WebSocket请求内容如下：</p><p>![image-20201125233156498](/Users/yuanhao/Library/Application Support/typora-user-images/image-20201125233156498.png)</p><p>Upgrade：websocket，告诉服务器当前使用websocket协议</p><p>Sec-WebSocket-Key：浏览器生成的base64加密串，用于验证服务器的websocket有效性</p><p>服务端返回的内容如下：</p><p>![image-20201125233503618](/Users/yuanhao/Library/Application Support/typora-user-images/image-20201125233503618.png)</p><p>传统的HTTP只能用于客户端向服务端发送请求，有两种解决方式</p><ul><li>AJAX轮询（固定时间轮询）</li><li>Long Poll（阻塞轮询）</li></ul><p>上面两种情况，对服务器要求都很高，前者要求有很快的处理速度，后者要求有很高的并发量。而WebSocket的出现就是为了解决这两个问题。</p><p>WebSocket在完成握手之后，连接并不会消失，而客户端会通过回调的方式从服务端获取数据。</p><p>同时WebSocket支持全双工通信，服务端不必等待请求可以直接向客户端发送数据</p><p>![image-20201125234528499](/Users/yuanhao/Library/Application Support/typora-user-images/image-20201125234528499.png)</p><ul><li>全双工方式</li><li>减少通信量：不再频繁交换header信息</li><li>多路复用：多个URL可以使用同一个WebSocket连接</li><li>心跳包</li></ul><h3 id="典型应用：聊天室"><a href="#典型应用：聊天室" class="headerlink" title="典型应用：聊天室"></a>典型应用：聊天室</h3>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTTP </tag>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Typora快捷键</title>
      <link href="/Typora%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
      <url>/Typora%E5%BF%AB%E6%8D%B7%E9%94%AE/</url>
      
        <content type="html"><![CDATA[<h2 id="typora快捷键"><a href="#typora快捷键" class="headerlink" title="typora快捷键"></a>typora快捷键</h2><p>一级标题：⌘1 (command + 1)<br>二级标题：⌘2 (command + 2)<br>三级标题：⌘3 (command + 3)<br>四级标题：⌘4 (command + 4)<br>五级标题：⌘5 (command + 5)</p><p>段落：⌘o 不生效，快捷键冲突，使用⌃o (control + o)</p><p>提升标题级别：⌘= (command + =)<br>降低标题级别：⌘- (command + -)</p><p>表格：⌥⌘T (option + command + T)<br>代码块：⌥⌘C (option + command + C)<br>公式块：⌥⌘B (option + command + B)</p><p>引用：⌥⌘Q (option + command + Q)<br>有序列表：⌥⌘O (option + command + O)<br>无序列表：⌥⌘U (option + command + U)</p><p>任务列表：⌥⌘X (option + command + X)<br>列表缩进：<br>​ 增加缩进：⌘] ( command + ])<br>​ 减少缩进：⌘[ ( command + [)</p><p>链接引用：⌥⌘L (option + command + L)<br>脚注：⌥⌘R (option + command + R)</p><p>水平分割线：⇧⌘- (shift + command + -)</p><p>加粗：⌘B (command + B)<br>斜体：⌘I (command + I)<br>下划线：⌘U (command + U)</p><p>代码：⇧⌘<code>(shift + command +</code>)</p><p>内联公式：⌃M (control + M)<br>删除线：⌃~ (control + ~)<br>注释：⌃- (control + -)</p><p>超链接:⌘K (command + K)<br>图像：⌃⌘I (control + command + U)<br>清除样式：⌘\ (command + )</p><p>显示/隐藏侧边栏：⇧⌘L (shift + command + L)<br>大纲视图：⌃⌘1 (control + command + 1)<br>文档列表视图：⌃⌘2 (control + command +2)<br>文件树视图：⌃⌘3 (control + command + 3)</p>]]></content>
      
      
      <categories>
          
          <category> 效率 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> markdown </tag>
            
            <tag> typora </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git&amp;Gerrit</title>
      <link href="/Git&amp;Gerrit/"/>
      <url>/Git&amp;Gerrit/</url>
      
        <content type="html"><![CDATA[<h2 id="Git基本知识"><a href="#Git基本知识" class="headerlink" title="Git基本知识"></a>Git基本知识</h2><p>推荐一个Git可视化动画练习的网站<a href="https://learngitbranching.js.org/?locale=zh_CN">https://learngitbranching.js.org/?locale=zh_CN</a></p><p>在熟悉Git前需要先了解三个基本概念：</p><ol><li>工作区：可以理解为当前的工程文件夹</li><li>暂存区：暂时保存对工作区的修改，需要commit才能将暂存区的修改实现相对永久的保存</li><li>远程仓库：存储代码的远端Git服务器</li></ol><h3 id="安装Git"><a href="#安装Git" class="headerlink" title="安装Git"></a>安装Git</h3><p>略去安装过程，安装结束后需要指定本机用户名和邮箱</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git config <span class="operator">--</span>global user.name <span class="string">&quot;Your Name&quot;</span></span><br><span class="line">$ git config <span class="operator">--</span>global user.email <span class="string">&quot;email@example.com&quot;</span></span><br></pre></td></tr></table></figure><h3 id="Git的基本操作"><a href="#Git的基本操作" class="headerlink" title="Git的基本操作"></a>Git的基本操作</h3><ol><li>创建仓库<code>git init</code></li><li>添加文件到暂存区<code>git add readme.txt</code></li><li>从暂存区删除文件<code> git reset 文件名</code></li><li>提交修改<code>git commit –m &quot;wrote a readme file&quot;</code>-m为本次提交的说明，如果需要对上一次的提交进行补充，使用<code>git commit --amend</code></li><li>查看日志<code>git log</code>可以提交查看日志，看每次提交修改了什么，–pretty=oneline可以精简地以一行进行显示，commit id是每次提交的标识符</li><li>版本回退<code>git reset --hard HEAD^</code> <code>HEAD</code>表示本地仓库的当前版本，<code>HEAD^</code>为上一版本，<code>HEAD~X</code>为上X个版本</li><li>恢复新版本<code>git reflog</code>可以查看历史提交的commit id，然后使用<code>git reset id</code>即可回退至指定位置<br>查看仓库状态<code>git status</code>查看仓库状态</li><li>查看工作区和版本库的区别<code>git diff</code></li><li>撤销修改<code>git checkout -- file</code>，该命令可以丢弃工作区的修改，若file修改后未放到暂存区，则回到和版本库一样的状态；若放到暂存区修改，则回到放到暂存区后的样子，总之该指令会撤销工作区的修改。<br><strong>注: 凭借checkout，可以将误删的文件加回来！</strong></li><li>暂存区重新放回工作区（暂存区撤回）<code>git reset HEAD file</code></li><li>文件删除<code>git rm file</code> </li><li>推送到远程仓库<code>git remote origin 远端地址</code> + <code>git push –u origin master</code>  -u不仅会推送，还会将本地和远程关联，简化命令，然后就可以git push origin master即可。<br><strong>注意</strong>：连接远程库之前需要现在本地生成<code>ssh-key</code>并填写在远端才能成功push</li></ol><h3 id="分支操作"><a href="#分支操作" class="headerlink" title="分支操作"></a>分支操作</h3><ol><li><p>创建新分支并切换<code>git checkout –b dev</code> = <code>git branch dev</code> + <code>git checkout dev</code></p></li><li><p>查看分支<code>git branch</code></p></li><li><p>合并分支<code>git merge xxx</code>，例如想要将<code>test</code>分支合并至<code>master</code>分支，需要在master分支上使用<code>git merge test</code></p><p><strong>注</strong>：merge结束后会生成一个merge commit<br>（PS: 2020年起github启用main作为主分支）</p></li><li><p>分支变基<code>git rebase</code><br>关于变基这里可以举一个例子方便说明，比如你从<code>master</code>分支切出一个名为<code>develop</code>的分支，那么<code>develop</code>分支的基就是当前时间点的<code>master</code>；接下来你在<code>develop</code>分支上进行了开发，在本地提交了<code>commit</code>这个<code>commit</code>也是以<code>master</code>为基；过了一段时间<code>master</code>分支的内容被别人修改，此时你尝试push显然会失败；而如果你的<code>commit</code>是以最新时间点的<code>master</code>为基，就可以成功push，所以你需要找一种方法，能够让你的commit变成以最新时间点的<code>master</code>作为基，这就是rebase的作用。</p></li><li><p>删除分支<code>git branch –d xxx</code></p></li><li><p>当前工作环境保存<code>git stash</code>，相当于将当前的修改<strong>剪切</strong>并压栈，为了便于识别可以使用<code>git stash save &quot;name&quot;</code>指定名称，使用<code>git stash list</code>查看所有被保存的修改，使用<code>git stash pop stash@&#123;x&#125;</code>或者<code>git stash pop name</code>将修改出栈并应用到当前分支。<br><code>git stash pop</code> = <code>git stash apply xxx</code> + <code>git stash drop xxx</code>，所以如果不希望修改出栈，只希望将修改应用到当前分支，使用<code>git stash apply</code></p></li><li><p>复制指定commitid的提交到当前分支<code>git cherry-pick &#123;commitid&#125;</code></p></li><li><p>在远端开分支<code>git co -b xxx</code> + <code>git push xxx</code></p></li></ol><h3 id="项目管理"><a href="#项目管理" class="headerlink" title="项目管理"></a>项目管理</h3><p>安装子模块<code>git submodule update --init --recursive</code></p><h3 id="–soft-–mixed-–hard"><a href="#–soft-–mixed-–hard" class="headerlink" title="–soft –mixed –hard"></a>–soft –mixed –hard</h3><p>一些指令（比如<code>git reset</code>）中有–mode参数，含义如下：</p><ol><li>–soft：仅仅改变HEAD指针，不改变暂存区和工作区。</li><li>–mixed（默认）：改变HEAD指针，改变暂存区，不改变工作区。即目录下的文件不变动，changes回退至add之前</li><li>–hard：改变HEAD指针，改变暂存区和工作区。文件和changes均会变动</li></ol><h3 id="rebase-i"><a href="#rebase-i" class="headerlink" title="rebase -i"></a>rebase -i</h3><p><a href="https://git-scm.com/book/zh/v2/Git-%E5%B7%A5%E5%85%B7-%E9%87%8D%E5%86%99%E5%8E%86%E5%8F%B2">修改历史</a></p><p>已经提交了commit1<del>commit4，想要修改commit2的内容，可以使用`git rebase -i HEAD</del>3<code>在命令行中将commit2前面的</code>pick<code>改为</code>edit<code>然后</code>:wq<code>保存即可开始你的修改，修改完</code>git rebase –continue`收工</p><h3 id="Merge-or-Rebase"><a href="#Merge-or-Rebase" class="headerlink" title="Merge or Rebase ?"></a>Merge or Rebase ?</h3><p><code>merge</code>会产生merge commit，但是只需要解决一次冲突</p><p><code>rebase</code>不会产生merge commit，但是需要对每一个待rebase的commit都解决一次冲突</p><p>公司的日常开发要求尽量让整个工程在一条线上，即尽量使用<code>rebase</code></p><p>个人经验：如果需要开一个分支去完成一个周期较长的需求，在这个需求中你提交了许多的commit，那么在需求完成的时候，master分支必定被其他人修改过很多地方，这时候如果你去rebase的话，解决merge conflict会比较头疼，所以使用merge比较好；如果你做的需求只需要一两个commit，那么显然使用不会产生merge commit的rebase更好。</p><h3 id="submodule"><a href="#submodule" class="headerlink" title="submodule"></a>submodule</h3><p>添加子模块到指定目录<code>git submodule add</code>+<code>URL</code>+<code>Path</code></p><h2 id="Gerrit"><a href="#Gerrit" class="headerlink" title="Gerrit"></a>Gerrit</h2><p>公司使用Gerrit作为代码库，有一些特有的命令</p><ul><li>push代码 <code>git push origin HEAD:refs/for/分支名</code></li><li>向远端推送分支<code>git push origin 待推送分支名</code></li><li>删除远端分支<code>git push origin :待删除分支名</code>（一般需要权限）</li></ul><h2 id="问题记录"><a href="#问题记录" class="headerlink" title="问题记录"></a>问题记录</h2><h3 id="git-revert和git-cherry-pick"><a href="#git-revert和git-cherry-pick" class="headerlink" title="git revert和git cherry-pick"></a>git revert和git cherry-pick</h3><p>场景一：</p><ol><li><code>develop</code>分支上提交commit</li><li><code>develop</code>分支上切出<code>feature</code>分支</li><li><code>develop</code>分支对commit revert</li><li><code>feature</code> merge到<code>develop</code></li></ol><p>问题：从<code>feature</code> merge回<code>develop</code>后，<code>feature</code>中的commit能否被带回<code>develop</code>？</p><p>答：不会</p><p>由于<code>feature</code>中的commitId和步骤3中被revert的commitId一致，因此结果就是feature merge回develop后，该commit也是不存在的</p><p>场景二：</p><ol><li><code>develop</code>分支上切出<code>feature</code>分支</li><li><code>develop</code>分支上提交commit</li><li><code>feature</code>分支对commit进行cherry-pick</li><li><code>develop</code>分支对commit revert</li><li><code>feature</code> merge到<code>develop</code></li></ol><p>同样的问题：从<code>feature</code> merge回<code>develop</code>后，<code>feature</code>中的commit能否被带回<code>develop</code>？</p><p>答：会</p><p>因为cherry-pick虽然会将commit的内容搬过去，但是commitId会变，属于一个新的commit，不会被revert掉</p>]]></content>
      
      
      <categories>
          
          <category> 效率 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
