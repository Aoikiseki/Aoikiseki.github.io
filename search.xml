<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>HTTP</title>
      <link href="/HTTP/"/>
      <url>/HTTP/</url>
      
        <content type="html"><![CDATA[<h1 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h1><blockquote><p>HTTP是基于TCP协议实现的超文本传输协议</p></blockquote><h2 id="HTTP的特点"><a href="#HTTP的特点" class="headerlink" title="HTTP的特点"></a>HTTP的特点</h2><ul><li>C/S模式：客户端主动发出请求，服务端给予回应</li><li>简单快速：只需要传输路径和请求方法</li><li>灵活：通过Content-Type标识，允许传输任意数据类型</li><li><strong>无连接</strong>：与UDP的无连接不同，这里的无连接的意思是每个HTTP连接只处理一个请求。<br>随着网页越来越复杂，这种处理方式效率低下，开始使用<code>Connetcion: keep-alive</code>字段保持<strong>TCP</strong>连接不断开</li><li><strong>无状态</strong>：对事务的处理没有记忆能力，服务端不会记录客户端状态，这次请求依赖上次的请求仍然需要重传。<br>目前有cookie和session两种方式提高传输效率</li></ul><h2 id="URI、URL、URN"><a href="#URI、URL、URN" class="headerlink" title="URI、URL、URN"></a>URI、URL、URN</h2><ul><li>URI：统一资源标识符。可以对网络中的资源进行标识，使得资源之间能够被区分。</li><li>URL：统一资源定位符。对某一资源提供了具体的访问地址和访问方式。</li></ul><p>显然URI &gt;= URL，能够提供具体访问方式的资源都是URI，但是并不是所有URI都提供了访问方式 。HTTP请求中请求的是URI，但是由于绝大部分情况都是根据资源地址进行请求，所以大部分时候也是URL。</p><h2 id="HTTP的报文结构"><a href="#HTTP的报文结构" class="headerlink" title="HTTP的报文结构"></a>HTTP的报文结构</h2><h3 id="请求报文"><a href="#请求报文" class="headerlink" title="请求报文"></a>请求报文</h3><p>![image-20201115184052614](/Users/yuanhao/Library/Application Support/typora-user-images/image-20201115184052614.png)</p><p>上面图示的报文头包含了比较常用的报文头字段，只是所有报文头字段的一部分，报文头字段总体可以分为通用报文头、请求报文头、响应报文头和实体报文头四类，在HTTP/1.1中一共规范了47种报文头字段。</p><p>下面对比较常用的字段进行说明</p><ul><li>ACCEPT：浏览器端可以接受的媒体类型。比如text/html就是可以接受服务端返回的text/html类型，如果服务端没有对应类型，则返回406错误；而*/*代表浏览器可以接受所有类型。</li><li>Connection：<code>keep-alive</code>代表TCP连接不关闭，<code>close</code>代表TCP连接在一次请求后就会关闭。</li><li>Refer：告诉服务端，是从哪个页面链接过来的。</li><li>User-Agent：客户端的操作系统和浏览器版本</li><li>Content-Type：报文体内对象的媒体类型。在项目中比较常用的就是<code>application/json</code>。</li></ul><h3 id="响应报文"><a href="#响应报文" class="headerlink" title="响应报文"></a>响应报文</h3><p>![image-20201115191453071](/Users/yuanhao/Library/Application Support/typora-user-images/image-20201115191453071.png)</p><h2 id="HTTP的请求方法"><a href="#HTTP的请求方法" class="headerlink" title="HTTP的请求方法"></a>HTTP的请求方法</h2><ul><li><p>GET：用来请求和访问已被URI识别的资源。GET也可以用来发送表单，提交数据，但提交信息直接拼在URI后面，一个是安全隐患，一个是有长度限制（不同的浏览器限制不同）</p></li><li><p>POST：与GET功能类似，但是用来传输实体的主体。由于表单数据没有直接拼在URI后面，也没有大小限制，所以克服了GET请求的缺点。</p><p>但是不论是GET还是POST请求，都不安全，比如抓包软件都拦截，只是POST相比GET提交数据，安全了一丢丢。</p></li><li><p>PUT：从客户端向服务端传送的数据取代指定文档的内容，与POST的区别在于，PUT是幂等的而POST是非幂等的，比如创建对象用POST，更新对象用PUT。</p></li><li><p>HEAD：类似GET请求，只是响应中没有具体内容。用于探测某个链接是否有效。</p></li><li><p>DELETE：由于没有验证机制，几乎没人用。</p></li><li><p>OPTIONS</p></li><li><p>TRACE</p></li><li><p>CONNECT：开启客户端与所请求资源之间的双向通道，可以用来创建隧道。目前只在代理中用的比较多。</p></li></ul><h2 id="HTTP状态码"><a href="#HTTP状态码" class="headerlink" title="HTTP状态码"></a>HTTP状态码</h2><p>2XX成功</p><ul><li>200：已接受并成功返回。</li><li>202：已接受但尚未处理完。</li><li>206：服务器成功处理了部分GET请求。断点续传、流媒体传输常用。</li></ul><p>3XX重定向</p><ul><li>301：请求的资源被永久移动到新的URI</li><li>302：临时移动</li></ul><p>4XX服务端结果可能不尽人意</p><ul><li>400：客户端请求语法错误</li><li>401：身份认证</li><li>403：服务端理解客户端请求，但拒绝执行</li><li>404：找不到资源</li></ul><p>5XX服务器错误</p><ul><li>500：服务器内部错误</li><li>502：网关或代理与远端服务器传输数据时发生了错误</li></ul><h2 id="HTTP状态管理"><a href="#HTTP状态管理" class="headerlink" title="HTTP状态管理"></a>HTTP状态管理</h2><p>HTTP通过Cookie和Session的方式来进行状态管理，其中Cookie是客户端的状态，Session是服务端的状态。</p><h3 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h3><p>Cookie实际上是一小段文本信息，客户端请求服务器如果需要存储客户端的信息，则服务端会向客户端发送一段Cookie。客户端浏览器会将Cookie存储起来，当浏览器再请求该网站时，就会带上Cookie，服务器就可以凭借Cookie辨认用户。</p><h3 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h3><p>Session是服务端存储用户状态的方式，服务端收到客户端发送的请求后，若用户此前未请求过，则为用户创建一个Session并生成SessionID，并将SessionID返回给客户端，以后客户端发送请求时携带SessionID即可。</p><p>保存SessionID的方式：</p><ul><li>Cookie</li><li>URL重写</li><li>隐藏表单</li></ul><p>由于Session一般都放到服务端的缓存中，所以为了减缓存储压力，所以会对不活跃的Session进行释放，所以Session的有效期相对较短，而Cookie可以永久存储。</p><h2 id="字符集与编码"><a href="#字符集与编码" class="headerlink" title="字符集与编码"></a>字符集与编码</h2><h3 id="编码规范"><a href="#编码规范" class="headerlink" title="编码规范"></a>编码规范</h3><p>编码规范（比如Unicode）包括三部分：</p><ul><li>字库表</li><li>编码方式（比如UTF-8）</li><li>字符集</li></ul><p>常见的编码规范：</p><ul><li>ASCII：最为人熟知的编码方式，字符只占一个字节，但是可表达的字符非常少</li><li>GBK：所有字符都占两个字节</li><li>ISO-8859-1：也是只占一个字节，但是表示的是ASCII以外的字符。最大的特点就是其他任何的编码规范都可以尝试用ISO-8859-1进行解码，虽然结果很可能不是你想要的，很多时候乱码就是这样产生的，一些数据库也利用了这个特点。该规范不支持中文。</li><li>Unicode：ISO标准化组织定制的一种通用编码规范，该规范下包括utf-8（变长）、utf-16、utf-32编码方式</li></ul><p>编码：文字-&gt;机器码</p><p>解码：机器码-&gt;文字</p><h3 id="乱码是如何产生的？"><a href="#乱码是如何产生的？" class="headerlink" title="乱码是如何产生的？"></a>乱码是如何产生的？</h3><p>有两种可能</p><ol><li>编码和解码使用的规范不一致</li><li>编码和解码规范一致，但是字库表并没有这些字，比如使用iSO-8859-1对中文字符进行编码和解码，无法还原文本。</li></ol><h3 id="URL的编码和解码"><a href="#URL的编码和解码" class="headerlink" title="URL的编码和解码"></a>URL的编码和解码</h3><ul><li>URL使用ASCII字符集进行编码，因此如果URL含有非ASCII字符集的字符，则需要进行编码</li><li>URL中的一些保留字符，比如参数分隔符”&amp;”，如果想要使用保留字，也需要编码</li></ul><p>URL中的”%”编码规范</p><ul><li>对于URL中的ASCII字符集的非保留字不编码</li><li>对于保留字取其ASCII内码，然后加上%前缀进行编码</li><li>对于非ASCII字符取其Unicode内码，加上%前缀进行编码</li></ul><h2 id="身份认证"><a href="#身份认证" class="headerlink" title="身份认证"></a>身份认证</h2><ul><li>Basic认证：简单的Base64加密传输。</li><li>Digest摘要认证：HTTP/1.1起出现，服务端传送一个加密算法，客户端使用该加密算法进行加密传输。</li><li>SSL认证：借由HTTPS的客户端证书完成认证，具备一定的成本。</li><li>基于表单的认证：该认证方法并不是在HTTP协议中定义的，而是有Web应用程序进行实现，通过Cookie和Session保存用户状态。</li></ul><h2 id="长连接和短连接"><a href="#长连接和短连接" class="headerlink" title="长连接和短连接"></a>长连接和短连接</h2><p>长连接和短连接的概念其实是来描述TCP，而非HTTP的。</p><ul><li>短连接：建立连接、数据传输、关闭连接…建立连接、数据传输、关闭连接</li><li>长连接：建立连接、数据传输…数据传输、关闭连接</li></ul><h2 id="HTTP缓存"><a href="#HTTP缓存" class="headerlink" title="HTTP缓存"></a>HTTP缓存</h2><p>HTTP的缓存对象更多是静态资源文件、比如css、js、图片等资源。</p><h3 id="缓存头部字段："><a href="#缓存头部字段：" class="headerlink" title="缓存头部字段："></a>缓存头部字段：</h3><ul><li><p>Cache-Control请求/响应头，缓存控制字段</p><p>no-store：不缓存</p><p>no-cache：缓存，但是使用缓存前需要询问服务器资源是否最新</p><p>public：客户端和代理服务器都可以缓存</p><p>private：客户端可以缓存</p><p>max-age=x：请求缓存后的X秒内不再发起请求</p><p>s-maxage=x：作用同上，用于代理服务器和源站</p></li><li><p>Expires响应头，过期时间</p></li><li><p>Last-Modified响应头，资源最新修改时o间</p><p>if-Modified-Since请求头，资源最新修改时间</p></li><li><p>Etag响应头，资源标识</p><p>if-None-Match请求头，缓存资源标识</p></li></ul><h3 id="缓存的三种工作场景："><a href="#缓存的三种工作场景：" class="headerlink" title="缓存的三种工作场景："></a>缓存的三种工作场景：</h3><ul><li><p>客户端向服务端请求资源，服务端返回资源+Expires，客户端再次请求前先去查看Expires</p></li><li><p>客户端向服务端请求资源，服务端返回资源+Expires+Last-Modified，客户端再次请求会带上if-Modified-Since，若服务端比对发现资源仍然未改动，则直接返回304</p><p>两个问题：</p><ol><li>Expires在客户端可以被修改，因此不稳定</li><li>Last-Modified只能精确到秒级，造成无法及时更新（可以抓包看一下）</li></ol></li><li><p>客户端向服务端请求资源，服务端返回资源+Expires+Last-Modified+Etag+max-age，用max-age解决问题1，用Etag解决问题2，一旦比对Etag不匹配，则立即更新缓存</p></li></ul><h3 id="缓存改进方案"><a href="#缓存改进方案" class="headerlink" title="缓存改进方案"></a>缓存改进方案</h3><ul><li>md5/hash缓存</li><li>CDN（目前最常用）</li></ul><h2 id="断点续传"><a href="#断点续传" class="headerlink" title="断点续传"></a>断点续传</h2><p>下载使用的也是HTTP协议，可以在Range字段中指定要下载的范围</p><p>HTTP/1.1 200 OK 不使用断点续传</p><p>HTTP/1.1 206 Partial Content 使用断点续传</p><h1 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h1><p>http协议不对内容进行加密，容易被截获和修改</p><h2 id="非对称加密"><a href="#非对称加密" class="headerlink" title="非对称加密"></a>非对称加密</h2><p>A与B进行通信，分三步</p><ul><li>A向B发送Public Key</li><li>B收到Public Key后将准备进行通信的Core Key使用Public Key进行加密得到Secret Key，发送给A</li><li>A收到Secret Key后使用Private Key解密得到Core Key</li></ul><p>这样，即使Public Key在最开始被截获，但是真正用于加密通信的Core Key在网络上没有明文传输，所以是<strong>相对</strong>安全的。非对称加密并不是绝对安全的，因为中间人可能会在第一步截获Public Key，并偷梁换柱向B发送自己制造的Public Key2，从而影响后续的信息传输。</p><h2 id="证书机制"><a href="#证书机制" class="headerlink" title="证书机制"></a>证书机制</h2><p>考虑到非对称加密并非绝对安全，这里引入了证书机构，一般来说我们的浏览器中都设置好了各大证书机构的信息，所以浏览器可以直接进行解密。</p><p>还是A与B进行通信</p><ul><li>A通过向证书机构发送Public Key得到下发的证书，并向B发送证书而非Public Key</li><li>B使用证书机构的公钥对证书进行解密得到Public Key，并将Core Key加密为Secret Key，发送给A</li><li>A收到Secret Key后使用Private Key解密得到Core Key</li></ul><p>整个流程后50%没有变化，只是前50%的流程引入了证书机构</p><h1 id="WebSocket"><a href="#WebSocket" class="headerlink" title="WebSocket"></a>WebSocket</h1><p>WebSocket是HTTP的长连接实现，并且兼容了现有的HTTP协议</p><h2 id="WebSocket的握手"><a href="#WebSocket的握手" class="headerlink" title="WebSocket的握手"></a>WebSocket的握手</h2><p>WebSocket借用HTTP完成握手</p><p>客户端向服务端发送的WebSocket请求内容如下：</p><p>![image-20201125233156498](/Users/yuanhao/Library/Application Support/typora-user-images/image-20201125233156498.png)</p><p>Upgrade：websocket，告诉服务器当前使用websocket协议</p><p>Sec-WebSocket-Key：浏览器生成的base64加密串，用于验证服务器的websocket有效性</p><p>服务端返回的内容如下：</p><p>![image-20201125233503618](/Users/yuanhao/Library/Application Support/typora-user-images/image-20201125233503618.png)</p><p>传统的HTTP只能用于客户端向服务端发送请求，有两种解决方式</p><ul><li>AJAX轮询（固定时间轮询）</li><li>Long Poll（阻塞轮询）</li></ul><p>上面两种情况，对服务器要求都很高，前者要求有很快的处理速度，后者要求有很高的并发量。而WebSocket的出现就是为了解决这两个问题。</p><p>WebSocket在完成握手之后，连接并不会消失，而客户端会通过回调的方式从服务端获取数据。</p><p>同时WebSocket支持全双工通信，服务端不必等待请求可以直接向客户端发送数据</p><p>![image-20201125234528499](/Users/yuanhao/Library/Application Support/typora-user-images/image-20201125234528499.png)</p><ul><li>全双工方式</li><li>减少通信量：不再频繁交换header信息</li><li>多路复用：多个URL可以使用同一个WebSocket连接</li><li>心跳包</li></ul><h3 id="典型应用：聊天室"><a href="#典型应用：聊天室" class="headerlink" title="典型应用：聊天室"></a>典型应用：聊天室</h3>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTTP </tag>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Typora快捷键</title>
      <link href="/Typora%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
      <url>/Typora%E5%BF%AB%E6%8D%B7%E9%94%AE/</url>
      
        <content type="html"><![CDATA[<h2 id="typora快捷键"><a href="#typora快捷键" class="headerlink" title="typora快捷键"></a>typora快捷键</h2><p>一级标题：⌘1 (command + 1)<br>二级标题：⌘2 (command + 2)<br>三级标题：⌘3 (command + 3)<br>四级标题：⌘4 (command + 4)<br>五级标题：⌘5 (command + 5)</p><p>段落：⌘o 不生效，快捷键冲突，使用⌃o (control + o)</p><p>提升标题级别：⌘= (command + =)<br>降低标题级别：⌘- (command + -)</p><p>表格：⌥⌘T (option + command + T)<br>代码块：⌥⌘C (option + command + C)<br>公式块：⌥⌘B (option + command + B)</p><p>引用：⌥⌘Q (option + command + Q)<br>有序列表：⌥⌘O (option + command + O)<br>无序列表：⌥⌘U (option + command + U)</p><p>任务列表：⌥⌘X (option + command + X)<br>列表缩进：<br>​ 增加缩进：⌘] ( command + ])<br>​ 减少缩进：⌘[ ( command + [)</p><p>链接引用：⌥⌘L (option + command + L)<br>脚注：⌥⌘R (option + command + R)</p><p>水平分割线：⇧⌘- (shift + command + -)</p><p>加粗：⌘B (command + B)<br>斜体：⌘I (command + I)<br>下划线：⌘U (command + U)</p><p>代码：⇧⌘<code>(shift + command +</code>)</p><p>内联公式：⌃M (control + M)<br>删除线：⌃~ (control + ~)<br>注释：⌃- (control + -)</p><p>超链接:⌘K (command + K)<br>图像：⌃⌘I (control + command + U)<br>清除样式：⌘\ (command + )</p><p>显示/隐藏侧边栏：⇧⌘L (shift + command + L)<br>大纲视图：⌃⌘1 (control + command + 1)<br>文档列表视图：⌃⌘2 (control + command +2)<br>文件树视图：⌃⌘3 (control + command + 3)</p>]]></content>
      
      
      <categories>
          
          <category> 效率 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> markdown </tag>
            
            <tag> typora </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git&amp;Gerrit</title>
      <link href="/Git&amp;Gerrit/"/>
      <url>/Git&amp;Gerrit/</url>
      
        <content type="html"><![CDATA[<h2 id="Git基本知识"><a href="#Git基本知识" class="headerlink" title="Git基本知识"></a>Git基本知识</h2><p>推荐一个Git可视化动画练习的网站<a href="https://learngitbranching.js.org/?locale=zh_CN">https://learngitbranching.js.org/?locale=zh_CN</a></p><p>在熟悉Git前需要先了解三个基本概念：</p><ol><li>工作区：可以理解为当前的工程文件夹</li><li>暂存区：暂时保存对工作区的修改，需要commit才能将暂存区的修改实现相对永久的保存</li><li>远程仓库：存储代码的远端Git服务器</li></ol><h3 id="安装Git"><a href="#安装Git" class="headerlink" title="安装Git"></a>安装Git</h3><p>略去安装过程，安装结束后需要指定本机用户名和邮箱</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git config <span class="operator">--</span>global user.name <span class="string">&quot;Your Name&quot;</span></span><br><span class="line">$ git config <span class="operator">--</span>global user.email <span class="string">&quot;email@example.com&quot;</span></span><br></pre></td></tr></table></figure><h3 id="Git的基本操作"><a href="#Git的基本操作" class="headerlink" title="Git的基本操作"></a>Git的基本操作</h3><ol><li>创建仓库<code>git init</code></li><li>添加文件到暂存区<code>git add readme.txt</code></li><li>从暂存区删除文件<code> git reset 文件名</code></li><li>提交修改<code>git commit –m &quot;wrote a readme file&quot;</code>-m为本次提交的说明，如果需要对上一次的提交进行补充，使用<code>git commit --amend</code></li><li>查看日志<code>git log</code>可以提交查看日志，看每次提交修改了什么，–pretty=oneline可以精简地以一行进行显示，commit id是每次提交的标识符</li><li>版本回退<code>git reset --hard HEAD^</code> <code>HEAD</code>表示本地仓库的当前版本，<code>HEAD^</code>为上一版本，<code>HEAD~X</code>为上X个版本</li><li>恢复新版本<code>git reflog</code>可以查看历史提交的commit id，然后使用<code>git reset id</code>即可回退至指定位置<br>查看仓库状态<code>git status</code>查看仓库状态</li><li>查看工作区和版本库的区别<code>git diff</code></li><li>撤销修改<code>git checkout -- file</code>，该命令可以丢弃工作区的修改，若file修改后未放到暂存区，则回到和版本库一样的状态；若放到暂存区修改，则回到放到暂存区后的样子，总之该指令会撤销工作区的修改。<br><strong>注: 凭借checkout，可以将误删的文件加回来！</strong></li><li>暂存区重新放回工作区（暂存区撤回）<code>git reset HEAD file</code></li><li>文件删除<code>git rm file</code> </li><li>推送到远程仓库<code>git remote origin 远端地址</code> + <code>git push –u origin master</code>  -u不仅会推送，还会将本地和远程关联，简化命令，然后就可以git push origin master即可。<br><strong>注意</strong>：连接远程库之前需要现在本地生成<code>ssh-key</code>并填写在远端才能成功push</li></ol><h3 id="分支操作"><a href="#分支操作" class="headerlink" title="分支操作"></a>分支操作</h3><ol><li><p>创建新分支并切换<code>git checkout –b dev</code> = <code>git branch dev</code> + <code>git checkout dev</code></p></li><li><p>查看分支<code>git branch</code></p></li><li><p>合并分支<code>git merge xxx</code>，例如想要将<code>test</code>分支合并至<code>master</code>分支，需要在master分支上使用<code>git merge test</code></p><p><strong>注</strong>：merge结束后会生成一个merge commit<br>（PS: 2020年起github启用main作为主分支）</p></li><li><p>分支变基<code>git rebase</code><br>关于变基这里可以举一个例子方便说明，比如你从<code>master</code>分支切出一个名为<code>develop</code>的分支，那么<code>develop</code>分支的基就是当前时间点的<code>master</code>；接下来你在<code>develop</code>分支上进行了开发，在本地提交了<code>commit</code>这个<code>commit</code>也是以<code>master</code>为基；过了一段时间<code>master</code>分支的内容被别人修改，此时你尝试push显然会失败；而如果你的<code>commit</code>是以最新时间点的<code>master</code>为基，就可以成功push，所以你需要找一种方法，能够让你的commit变成以最新时间点的<code>master</code>作为基，这就是rebase的作用。</p></li><li><p>删除分支<code>git branch –d xxx</code></p></li><li><p>当前工作环境保存<code>git stash</code>，相当于将当前的修改<strong>剪切</strong>并压栈，为了便于识别可以使用<code>git stash save &quot;name&quot;</code>指定名称，使用<code>git stash list</code>查看所有被保存的修改，使用<code>git stash pop stash@&#123;x&#125;</code>或者<code>git stash pop name</code>将修改出栈并应用到当前分支。<br><code>git stash pop</code> = <code>git stash apply xxx</code> + <code>git stash drop xxx</code>，所以如果不希望修改出栈，只希望将修改应用到当前分支，使用<code>git stash apply</code></p></li><li><p>复制指定commitid的提交到当前分支<code>git cherry-pick &#123;commitid&#125;</code></p></li><li><p>在远端开分支<code>git co -b xxx</code> + <code>git push xxx</code></p></li></ol><h3 id="项目管理"><a href="#项目管理" class="headerlink" title="项目管理"></a>项目管理</h3><p>安装子模块<code>git submodule update --init --recursive</code></p><h3 id="–soft-–mixed-–hard"><a href="#–soft-–mixed-–hard" class="headerlink" title="–soft –mixed –hard"></a>–soft –mixed –hard</h3><p>一些指令（比如<code>git reset</code>）中有–mode参数，含义如下：</p><ol><li>–soft：仅仅改变HEAD指针，不改变暂存区和工作区。</li><li>–mixed（默认）：改变HEAD指针，改变暂存区，不改变工作区。即目录下的文件不变动，changes回退至add之前</li><li>–hard：改变HEAD指针，改变暂存区和工作区。文件和changes均会变动</li></ol><h3 id="rebase-i"><a href="#rebase-i" class="headerlink" title="rebase -i"></a>rebase -i</h3><p><a href="https://git-scm.com/book/zh/v2/Git-%E5%B7%A5%E5%85%B7-%E9%87%8D%E5%86%99%E5%8E%86%E5%8F%B2">修改历史</a></p><p>已经提交了commit1<del>commit4，想要修改commit2的内容，可以使用`git rebase -i HEAD</del>3<code>在命令行中将commit2前面的</code>pick<code>改为</code>edit<code>然后</code>:wq<code>保存即可开始你的修改，修改完</code>git rebase –continue`收工</p><h3 id="Merge-or-Rebase"><a href="#Merge-or-Rebase" class="headerlink" title="Merge or Rebase ?"></a>Merge or Rebase ?</h3><p><code>merge</code>会产生merge commit，但是只需要解决一次冲突</p><p><code>rebase</code>不会产生merge commit，但是需要对每一个待rebase的commit都解决一次冲突</p><p>公司的日常开发要求尽量让整个工程在一条线上，即尽量使用<code>rebase</code></p><p>个人经验：如果需要开一个分支去完成一个周期较长的需求，在这个需求中你提交了许多的commit，那么在需求完成的时候，master分支必定被其他人修改过很多地方，这时候如果你去rebase的话，解决merge conflict会比较头疼，所以使用merge比较好；如果你做的需求只需要一两个commit，那么显然使用不会产生merge commit的rebase更好。</p><h3 id="submodule"><a href="#submodule" class="headerlink" title="submodule"></a>submodule</h3><p>添加子模块到指定目录<code>git submodule add</code>+<code>URL</code>+<code>Path</code></p><h2 id="Gerrit"><a href="#Gerrit" class="headerlink" title="Gerrit"></a>Gerrit</h2><p>公司使用Gerrit作为代码库，有一些特有的命令</p><ul><li>push代码 <code>git push origin HEAD:refs/for/分支名</code></li><li>向远端推送分支<code>git push origin 待推送分支名</code></li><li>删除远端分支<code>git push origin :待删除分支名</code>（一般需要权限）</li></ul><h2 id="问题记录"><a href="#问题记录" class="headerlink" title="问题记录"></a>问题记录</h2><h3 id="git-revert和git-cherry-pick"><a href="#git-revert和git-cherry-pick" class="headerlink" title="git revert和git cherry-pick"></a>git revert和git cherry-pick</h3><p>场景一：</p><ol><li><code>develop</code>分支上提交commit</li><li><code>develop</code>分支上切出<code>feature</code>分支</li><li><code>develop</code>分支对commit revert</li><li><code>feature</code> merge到<code>develop</code></li></ol><p>问题：从<code>feature</code> merge回<code>develop</code>后，<code>feature</code>中的commit能否被带回<code>develop</code>？</p><p>答：不会</p><p>由于<code>feature</code>中的commitId和步骤3中被revert的commitId一致，因此结果就是feature merge回develop后，该commit也是不存在的</p><p>场景二：</p><ol><li><code>develop</code>分支上切出<code>feature</code>分支</li><li><code>develop</code>分支上提交commit</li><li><code>feature</code>分支对commit进行cherry-pick</li><li><code>develop</code>分支对commit revert</li><li><code>feature</code> merge到<code>develop</code></li></ol><p>同样的问题：从<code>feature</code> merge回<code>develop</code>后，<code>feature</code>中的commit能否被带回<code>develop</code>？</p><p>答：会</p><p>因为cherry-pick虽然会将commit的内容搬过去，但是commitId会变，属于一个新的commit，不会被revert掉</p>]]></content>
      
      
      <categories>
          
          <category> 效率 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
